<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>

</head>
<body>
    <h3>자바스크립트의 오브젝트</h3>    
    <ul>
        <li> - 자바스크립트의 객체를 정의하기: 기호 {}</li>
        <li> - 자바에서는 객체의 구성요소 - 속성과 메소드 -> 미리 클래스로 정의</li>
        <li> - 자바스크립트는 구성요소를 미리 정의하지않는 프로토타입 기반 객체</li>
        <li> - → 구성요소인 속성과 메소드의 추가가 가능</li>
    </ul>
    <pre style="font-size: 1.2rem; font-family: inherit;">
        <script>
            //객체 리터럴을 const 변수 sana에 대입 - 객체이름:sana
            // key: value ->map과 유사
            const sana = {name:'사나', age:23, address:'경기'}
            document.writeln('sana 이름=', sana.name)
            document.writeln('sana 나이=', sana.age)
            document.writeln('sana 주소=', sana.address)
            document.writeln('sana =', sana)
            console.log('sana=',sana)
            sana.height=172;
            console.log('sana=',sana)

            //객체의 메소드는 함수 리터럴(문자)로 정의
            // 새로운 속성(프로퍼티) 이름은 hello, 값은 함수 => hello 메소드
            sana.hello = function(){
                alert(`안녕하세요. 나는 ${this.name}입니다.`)
            }

            sana.hello();
            sana.name='sanaaaa'
            sana.hello();

            //구성요소가 없는 객체리터럴 선언
            const momo= {}
            momo.color = 'red';

            // 배열값이 없는 빈 배열 선언
            const arr=[];
            // 배열값 형식이 달라도 저장할 수 있음
            const arrr=['a',123,new Date()];
            
            // 객체의 구성요소가 다르지만 같은 배열에 저장 가능
            const objarr = [momo, sana];
            console.log(objarr);



        </script>
        <!-- 공공데이터 rest api에서 받는 데이터 형식 중 하나가 자바스크립트 객체와 변환되는 json이라는 문자열(*****)
            rest api는 데이터를 전송받을때 사용하는 하나의 규칙(프로토콜..)
            -서버의 주소, 파라미터(요청값), method, 자원의 위치(url)를 요청하면 응답으로 xml , json.. 등의 형식 데이터를 응답받음
            rest api 요청을 자바스크립트의 비동기 통신방식으로 보냄
                -비동기 통신은 요청과 응답의 순서가 없음 -> 백그라운드에서 요청을 보내기에
        -->


    </pre>
    
</body>
</html>